<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
    <title>Humbe | Caza Nubes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet" />
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: #111;
        font-family:
          "Roboto",
          system-ui,
          -apple-system,
          Segoe UI,
          Arial,
          sans-serif;
      }
      body {
        touch-action: manipulation;
        overscroll-behavior: none;
      }
      #wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      @supports (min-height: 100dvh) {
        #wrap {
          min-height: 100dvh;
        }
      }

      /* Canvas 16:9 responsive */
      canvas {
        display: block;
        border-radius: 12px;
        box-shadow: 0 10px 28px #0006;
        aspect-ratio: 16/9;
        width: min(100vw, calc(100vh * (16 / 9)));
        height: auto;
        max-width: 100vw;
        max-height: 100vh;
      }
      @supports (width: 100svw) {
        canvas {
          width: min(100svw, calc(100svh * (16 / 9)));
          max-width: 100svw;
          max-height: 100svh;
        }
      }
      @supports (width: 100dvw) {
        canvas {
          width: min(100dvw, calc(100dvh * (16 / 9)));
          max-width: 100dvw;
          max-height: 100dvh;
        }
      }

      .hud {
        position: fixed;
        top: 10px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 8px;
        pointer-events: none;
        padding: env(safe-area-inset-top) 0 0;
      }
      .card {
        background: #fff;
        color: #222;
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 14px;
      }
      #muteBtn {
        pointer-events: auto;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
      }
      #muteBtn[aria-pressed="true"] {
        background: #222;
        color: #ffd33d;
        outline: 2px solid #ffd33d;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        background: #0007;
        color: #fff;
        text-align: center;
        padding: 20px;
        backdrop-filter: blur(2px);
        pointer-events: auto;
      }
      .overlay.show {
        display: grid;
      }
      .overlay > div {
        pointer-events: none;
      }
      .btn {
        display: inline-block;
        margin-top: 10px;
        padding: 10px 44px;
        border-radius: 12px;
        background: #ffd33d;
        color: #000;
        font-weight: 800;
        cursor: pointer;
        user-select: none;
        pointer-events: auto;
        transition: all ease 300ms;
        border: 2px solid #000;
      }
      .btn:hover {
        transform: scale(1.2);
        box-shadow: #1d01ff 5px 5px 0px;
      }
      .stats {
        font-weight: 700;
        font-size: 18px;
        margin: 8px 0 4px;
      }
      #jumpBtn {
        position: fixed;
        right: 14px;
        bottom: max(14px, env(safe-area-inset-bottom));
        padding: 16px 18px;
        border-radius: 999px;
        background: #ffd33d;
        color: #000;
        font-weight: 900;
        box-shadow: 0 6px 18px #0006;
        user-select: none;
      }
      #title img {
        display: block;
        margin: 12px auto 0;
        max-width: min(92vw, 480px);
        height: auto;
      }
      @media (min-width: 720px) {
        #jumpBtn {
          display: none;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
        }
      }

      .animate {
        display: inline-grid;
        place-items: center;
        user-select: none;
        will-change: transform, filter;
      }
      .pulse {
        --pulse-scale: 1.08;
        --pulse-dur: 1.2s;
        --pulse-ease: ease-in-out;
        --pulse-glow: 0 0 0px rgba(255, 211, 61, 0);
        animation: pulse var(--pulse-dur) var(--pulse-ease) infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          filter: none;
          box-shadow: var(--pulse-glow);
        }
        50% {
          transform: scale(var(--pulse-scale));
          box-shadow: var(--pulse-glow);
        }
      }
      .spin {
        --spin-dur: 4s;
        animation: spin var(--spin-dur) linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .float {
        --float-dy: 10px;
        --float-dur: 3s;
        --float-ease: ease-in-out;
        animation: float var(--float-dur) var(--float-ease) infinite;
      }
      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(calc(-1 * var(--float-dy)));
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .pulse,
        .spin,
        .float {
          animation: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="game"></canvas>

      <div class="hud">
        <div class="card">Puntos <span id="points">0</span></div>
        <div class="card">Distancia <span id="meters">0</span> m</div>
        <div class="card">ü•á <span id="best">0</span></div>
        <button
          id="muteBtn"
          class="card"
          type="button"
          aria-pressed="false"
          aria-label="Silenciar sonido">
          üîä Sonido
        </button>
      </div>

      <div id="overlay" class="overlay" aria-live="polite">
        <div>
          <div id="title" class="animate float">
            <img
              src="assets/caza.webp"
              alt="Bienvenido a Humbe Runner"
              style="width: clamp(200px, 50%, 400px)" />
          </div>

          <p id="subtitle">
            Evita obst√°culos
            <img src="assets/BadCloud.webp" alt="" width="20" />
            <img src="assets/Rayo.webp" alt="" width="20" />
            y atrapa
            <img src="assets/Star.webp" width="20" alt="" />
            <img src="assets/GoodCloud.webp" width="20" alt="" />. <br />tap /
            espacio para saltar
          </p>
          <p id="stats" class="stats" style="display: none"></p>
          <div class="btn" id="startBtn">Jugar</div>
        </div>
      </div>

      <div id="jumpBtn" role="button" aria-label="Saltar">‚§¥Ô∏é</div>
    </div>

    <!-- BGM + SFX -->
    <audio id="bgm" src="assets/sound.mp3" preload="auto" loop></audio>
    <audio id="sfxJump" src="assets/jump.mp3" preload="auto"></audio>
    <audio id="sfxStar" src="assets/collect.mp3" preload="auto"></audio>
    <audio id="sfxBonus" src="assets/point.mp3" preload="auto"></audio>
    <audio id="sfxOver" src="assets/lose.mp3" preload="auto"></audio>

    <!-- Juego -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // =============== Orientaci√≥n (gate) ===============
        (() => {
          const isTouch = () =>
            "ontouchstart" in window || navigator.maxTouchPoints > 0;
          const isMobileUA =
            /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            );
          const isMobile = () => isTouch() && isMobileUA;
          const isPortrait = () =>
            window.matchMedia
              ? window.matchMedia("(orientation: portrait)").matches
              : window.innerHeight >= window.innerWidth;

          const overlay = document.createElement("div");
          overlay.id = "rotateOverlay";
          overlay.setAttribute("aria-hidden", "true");
          overlay.style.cssText =
            "position:fixed;inset:0;display:none;place-items:center;background:#000c;z-index:99999;color:#fff;text-align:center;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;backdrop-filter:blur(2px)";
          overlay.innerHTML = `
            <div style="max-width:560px">
              <div style="font-size:64px;line-height:1;margin-bottom:12px">üîÅ</div>
              <h2 style="margin:0 0 6px;font-size:22px">Gira tu dispositivo</h2>
              <p style="margin:0;opacity:.9">Este juego funciona mejor en <b>horizontal</b>.</p>
            </div>`;
          document.body.appendChild(overlay);

          const bgm = document.getElementById("bgm");
          const canvas = document.getElementById("game");
          let bgmWasPlaying = false;
          let rafGate;

          function showGate() {
            overlay.style.display = "grid";
            overlay.setAttribute("aria-hidden", "false");
            if (canvas) canvas.style.opacity = "0.001";
            if (bgm) {
              bgmWasPlaying = !bgm.paused;
              try {
                bgm.pause();
              } catch {}
            }
          }
          function hideGate() {
            overlay.style.display = "none";
            overlay.setAttribute("aria-hidden", "true");
            if (canvas) canvas.style.opacity = "";
            if (bgm && bgmWasPlaying) {
              bgm.play().catch(() => {});
            }
          }
          const applyGate = () => {
            if (!isMobile()) {
              hideGate();
              return;
            }
            if (isPortrait()) showGate();
            else hideGate();
          };
          const debouncedApplyGate = () => {
            cancelAnimationFrame(rafGate);
            rafGate = requestAnimationFrame(applyGate);
          };

          async function requestLandscapeLock() {
            try {
              if (screen.orientation && screen.orientation.lock) {
                await screen.orientation.lock("landscape");
              }
            } catch {}
          }

          const startBtn = document.getElementById("startBtn");
          if (startBtn) {
            startBtn.addEventListener(
              "click",
              () => {
                requestLandscapeLock();
                debouncedApplyGate();
              },
              { passive: true }
            );
          }

          window.addEventListener("resize", debouncedApplyGate, {
            passive: true,
          });
          window.addEventListener(
            "orientationchange",
            () => setTimeout(debouncedApplyGate, 80),
            { passive: true }
          );
          if (window.visualViewport) {
            visualViewport.addEventListener("resize", debouncedApplyGate, {
              passive: true,
            });
          }
          document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") debouncedApplyGate();
          });

          applyGate();
          window.__applyOrientationGate = applyGate;
        })();

        // =============== Juego ===============
        (() => {
          // ---------- Canvas ----------
          const c = document.getElementById("game");
          const ctx = c.getContext("2d", { alpha: true });
          const V = { W: 960, H: 540, aspect: 16 / 9 };

          let DPR = 1,
            SCALE = 1;
          function getViewportSize() {
            const vw = Math.floor(
              window.visualViewport?.width ?? window.innerWidth
            );
            const vh = Math.floor(
              window.visualViewport?.height ?? window.innerHeight
            );
            return { vw, vh };
          }
          function fit() {
            DPR = Math.min(2, window.devicePixelRatio || 1);
            const { vw, vh } = getViewportSize();
            SCALE = Math.min(vw / V.W, vh / V.H);
            c.style.width = V.W * SCALE + "px";
            c.style.height = V.H * SCALE + "px";
            c.width = Math.round(V.W * DPR);
            c.height = Math.round(V.H * DPR);
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          }
          addEventListener("resize", fit, { passive: true });
          addEventListener("orientationchange", fit, { passive: true });
          if (window.visualViewport)
            visualViewport.addEventListener("resize", fit, { passive: true });
          fit();

          // Helpers
          const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
          const rand = (a, b) => a + Math.random() * (b - a);
          function safeDraw(imgEl, ...args) {
            if (!imgEl || !imgEl.complete || imgEl.naturalWidth === 0) return;
            ctx.drawImage(imgEl, ...args);
          }
          function bubbleTarget() {
            const p = S.player;
            return { x: p.x + p.w * 0.55, y: p.y - p.h - 50 };
          }

          // ---------- ASSETS ----------
          const assets = {
            bg: "assets/SkyBack.webp",
            ground: "assets/BaseFront.webp",
            groundFront: "assets/base.webp",
            star: "assets/Star.webp",
            starBonus: "assets/GoodCloud.webp",
            obstacle: "assets/Rayo.webp",
            meteor: "assets/meteorito.webp",
            bird: "assets/BadCloud.webp",
            player: {
              runL: "assets/Humbeleft.webp",
              runR: "assets/HumbeRigth.webp",
              jump: "assets/HumbeJump.webp",
            },
            gameOverImg: "assets/GAMEOVER.webp",
          };
          const METEOR_W = 500,
            METEOR_H = 401,
            METEOR_AR = METEOR_W / METEOR_H;
          const PLAYER_VOFFSET = 6,
            BLOCK_VOFFSET = 6;

          function loadImage(src) {
            const i = new Image();
            i.decoding = "async";
            i.loading = "eager";
            i.src = src;
            return i;
          }
          const img = {
            bg: loadImage(assets.bg),
            ground: loadImage(assets.ground),
            groundFront: loadImage(assets.groundFront),
            star: loadImage(assets.star),
            starBonus: loadImage(assets.starBonus),
            obstacle: loadImage(assets.obstacle),
            meteor: loadImage(assets.meteor),
            bird: loadImage(assets.bird),
            player: {
              runL: loadImage(assets.player.runL),
              runR: loadImage(assets.player.runR),
              jump: loadImage(assets.player.jump),
            },
          };

          // ---------- F√≠sica / Juego ----------
          const G = {
            gravity: 2200,
            jumpV: 860,
            groundY: () => V.H * 0.78,
            baseSpeed: 290,
            maxSpeed: 1000,
            speedUpEach: 14,
            speedUpDelta: 28,
            starEvery: [1.0, 2.0],
            obsEvery: [1.5, 3.2],
          };
          const BONUS = {
            prob: 0.18,
            speedMul: 1.4,
            ampX: 18,
            ampY: 66,
            freq: 1.8,
            driftY: -12,
            jitter: 22,
          };
          const STAR_SIZE = { collisionR: 18, visualScale: 1 };
          const BONUS_SIZE = { collisionR: 22, visualW: 3, visualH: 1.2 };

          // ---------- Frases ----------
          const PHRASES = Array.isArray(window.PHRASES)
            ? window.PHRASES
            : [
                "¬°Lo que tocas, oro se hace!",
                "¬°Eres lo que el Sol siempre quiso ser!",
                "¬°Ponte cerca pa‚Äô dec√≠rtelo al o√≠do: te necesito!",
                "¬°Yo espero por tu llegada!",
                "¬°Tan fr√≠o y aun as√≠ me arde!",
                "¬°Por ti, yo muevo el planeta completo!",
                "¬°Si el amor no quema, no es amar!",
                "¬°No me temas, soy extraordinario!",
                "¬°Nos hacemos eternos!",
                "¬°T√∫ eres para m√≠!",
                "¬°Contigo, yo volv√≠ a respirar!",
                "¬°Diez mil kil√≥metros correr√≠a por ti!",
                "¬°Ten la confianza y busca la vida!",
                "¬°Respira, que todo se alivia!",
              ];
          function makeShuffledBag(arr) {
            const a = (Array.isArray(arr) ? arr : []).filter((v) => v != null);
            for (let i = a.length - 1; i > 0; i--) {
              const j = (Math.random() * (i + 1)) | 0;
              [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
          }

          // ---------- üîä AUDIO ----------
          const muteBtn = document.getElementById("muteBtn");
          const bgm = document.getElementById("bgm");
          const sfxIds = ["sfxJump", "sfxStar", "sfxBonus", "sfxOver"];

          let audioReady = false;
          let muted = localStorage.getItem("humbe_muted") === "1";
          let MASTER_VOLUME = 0.03;

          function updateMuteButton() {
            if (!muteBtn) return;
            muteBtn.setAttribute("aria-pressed", muted ? "true" : "false");
            muteBtn.setAttribute(
              "aria-label",
              muted ? "Activar sonido" : "Silenciar sonido"
            );
            muteBtn.textContent = muted
              ? "üîá Sonido desactivado"
              : "üîä Sonido activado";
          }
          function applyMuteState() {
            if (bgm) {
              bgm.muted = muted;
              if (muted) {
                try {
                  bgm.pause();
                } catch {}
              } else if (audioReady) {
                bgm.volume = MASTER_VOLUME;
                bgm.play().catch(() => {});
              }
            }
            sfxIds.forEach((id) => {
              const a = document.getElementById(id);
              if (a) a.muted = muted;
            });
          }
          function primeAudioEl(a) {
            if (!a) return;
            const vol = a.volume;
            a.volume = 0;
            a.currentTime = 0;
            a.play()
              .then(() => {
                a.pause();
                a.currentTime = 0;
                a.volume = vol;
              })
              .catch(() => {
                a.volume = vol;
              });
          }
          async function unlockAudio() {
            if (audioReady) return;
            audioReady = true;
            try {
              sfxIds.forEach((id) => {
                const a = document.getElementById(id);
                if (a) {
                  a.volume = MASTER_VOLUME;
                  primeAudioEl(a);
                }
              });
              if (bgm) {
                bgm.volume = MASTER_VOLUME;
                bgm.muted = muted;
                if (!muted) {
                  await bgm.play().catch(() => {});
                }
              }
            } catch (err) {
              console.warn("Audio init:", err);
            }
            updateMuteButton();
          }
          function playSfx(id) {
            if (muted || !audioReady) return;
            const a = document.getElementById(id);
            if (!a) return;
            try {
              a.currentTime = 0;
              a.volume = MASTER_VOLUME;
              a.play().catch(() => {});
            } catch {}
          }
          if (muteBtn) {
            muteBtn.addEventListener("click", () => {
              muted = !muted;
              localStorage.setItem("humbe_muted", muted ? "1" : "0");
              updateMuteButton();
              applyMuteState();
            });
          }
          updateMuteButton();
          applyMuteState();

          // Primer gesto
          window.addEventListener(
            "pointerdown",
            () => {
              unlockAudio();
              applyMuteState();
            },
            { once: true, passive: true }
          );
          window.addEventListener(
            "keydown",
            (e) => {
              if (["Enter", "Space", "ArrowUp"].includes(e.code)) {
                unlockAudio();
                applyMuteState();
              }
            },
            { once: true }
          );

          // ---------- Estado ----------
          let S;
          let canRestartAt = 0;

          function reset() {
            S = {
              t: 0,
              running: false,
              score: 0,
              meters: 0,
              stars: 0,
              best: Number(localStorage.getItem("bestPoints") || 0),
              speed: G.baseSpeed,
              lastStar: 0,
              lastObs: 0,
              lastSpeedUp: 0,
              jumps: 0,
              player: {
                x: 120,
                y: G.groundY(),
                w: 72,
                h: 72,
                vy: 0,
                onGround: true,
                state: "runL",
                frameTimer: 0,
                runFps: 10,
              },
              obs: [],
              items: [],
              particles: [],
              front: {
                x: 0,
                speedMul: 1.15,
                y: G.groundY() - 0,
                h: 120,
                alpha: 1,
              },
              groundScroll: { x: 0, y: V.H * 0.66, h: 120, speedPx: 80 },
              bubble: null,
              phraseBag: makeShuffledBag(PHRASES || []),
            };
          }
          reset();

          function nextPhrase() {
            if (!S.phraseBag || S.phraseBag.length === 0)
              S.phraseBag = makeShuffledBag(PHRASES);
            const msg = S.phraseBag.pop();
            return typeof msg === "string" ? msg : "";
          }

          // ---------- Input ----------
          function jump() {
            if (!S.running) return;
            const p = S.player;
            if (p.onGround || S.jumps < 2) {
              p.vy = -G.jumpV;
              p.onGround = false;
              S.jumps++;
              p.state = "jump";
              playSfx("sfxJump");
            }
          }
          addEventListener("keydown", (e) => {
            if (["Space", "Enter", "ArrowUp"].includes(e.code))
              e.preventDefault();
            if (e.code === "ArrowUp") {
              if (S?.running) jump();
            }
          });
          c.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            if (S.running) jump();
          });
          const jumpBtnEl = document.getElementById("jumpBtn");
          if (jumpBtnEl)
            jumpBtnEl.addEventListener("pointerdown", (e) => {
              e.preventDefault();
              if (S.running) jump();
            });

          const overlay = document.getElementById("overlay");
          const subtitleEl = document.getElementById("subtitle");
          const statsEl = document.getElementById("stats");
          const startBtn = document.getElementById("startBtn");
          if (startBtn) {
            startBtn.onclick = (ev) => {
              ev.stopPropagation();
              if (performance.now() >= canRestartAt) start();
            };
          }

          // ---------- Spawns ----------
          function spawn(dt) {
            S.lastStar += dt;
            S.lastObs += dt;
            S.lastSpeedUp += dt;

            if (S.lastSpeedUp >= G.speedUpEach) {
              S.speed = Math.min(G.maxSpeed, S.speed + G.speedUpDelta);
              S.lastSpeedUp = 0;
            }

            if (S.lastStar >= rand(...G.starEvery)) {
              const isBonus = Math.random() < BONUS.prob;
              S.items.push({
                type: isBonus ? "bonus" : "star",
                x: V.W + 40,
                y: rand(V.H * 0.5, V.H * 0.72),
                r: isBonus ? BONUS_SIZE.collisionR : STAR_SIZE.collisionR,
                vScale: isBonus ? 1 : STAR_SIZE.visualScale || 1,
                vW: isBonus ? BONUS_SIZE.visualW : 0,
                vH: isBonus ? BONUS_SIZE.visualH : 0,
                vx: S.speed * (isBonus ? BONUS.speedMul : 1.0),
                t: 0,
                phase: rand(0, Math.PI * 2),
                ampX: BONUS.ampX * rand(0.6, 1.4),
                ampY: BONUS.ampY * rand(0.6, 1.4),
                freq: BONUS.freq * rand(0.7, 1.3),
                driftY: BONUS.driftY * rand(0.6, 1.4),
                jitter: BONUS.jitter,
              });
              S.lastStar = 0;
            }

            if (S.lastObs >= rand(...G.obsEvery)) {
              const r = Math.random();
              if (r < 0.55) {
                S.obs.push({
                  type: "block",
                  x: V.W + 40,
                  y: G.groundY(),
                  w: 60,
                  h: 60,
                  vx: S.speed,
                });
              } else if (r < 0.85) {
                S.obs.push({
                  type: "bird",
                  x: V.W + 40,
                  y: rand(V.H * 0.52, V.H * 0.64),
                  w: 60,
                  h: 40,
                  vx: S.speed,
                  flap: 0,
                });
              } else {
                const startX = rand(V.W * 0.7, V.W + 80),
                  startY = rand(-120, -40);
                const speed = rand(380, 520),
                  fall = rand(280, 380);
                const destH = 26 * 2.3,
                  destW = destH * METEOR_AR;
                S.obs.push({
                  type: "meteor",
                  x: startX,
                  y: startY,
                  vx: speed,
                  vy: fall,
                  dw: destW,
                  dh: destH,
                  rcx: -0.24,
                  rcy: 0.08,
                  rr: 0.18,
                });
              }
              S.lastObs = 0;
            }
          }

          // ---------- Colisiones / part√≠culas ----------
          const clampR = (cx, cy, r, rx, ry, rw, rh) => {
            const nx = clamp(cx, rx, rx + rw),
              ny = clamp(cy, ry, ry + rh);
            const dx = cx - nx,
              dy = cy - ny;
            return dx * dx + dy * dy <= r * r;
          };
          const aabb = (a, b) =>
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y;

          function puff(x, y, n = 6) {
            for (let i = 0; i < n; i++) {
              S.particles.push({
                type: "note",
                x,
                y,
                vx: rand(-120, 120),
                vy: rand(-220, -80),
                s: rand(18, 28),
                rot: rand(-0.35, 0.35),
                life: rand(0.8, 1.2),
              });
            }
          }

          // ---------- Loop ----------
          let last = performance.now();
          function loop(now) {
            try {
              const dt = Math.min((now - last) / 1000, 0.033);
              last = now;
              if (S.running) update(dt);
              draw();
            } catch (err) {
              console.error(err);
              if (overlay) overlay.classList.add("show");
              if (statsEl) {
                statsEl.style.display = "block";
                statsEl.textContent = "Error: " + (err?.message || String(err));
              }
            }
            requestAnimationFrame(loop);
          }
          requestAnimationFrame(loop);

          function update(dt) {
            S.t += dt;
            S.meters += S.speed * dt * 0.06;

            if (S.bubble && S.bubble.lockToPlayer) {
              const t = bubbleTarget();
              const followSpeed = 12;
              S.bubble.x += (t.x - S.bubble.x) * Math.min(1, dt * followSpeed);
              S.bubble.y += (t.y - S.bubble.y) * Math.min(1, dt * followSpeed);
              S.bubble.x = clamp(S.bubble.x, 16, V.W - 16);
              S.bubble.y = clamp(S.bubble.y, 16, V.H - 16);
            }

            // F√≠sica
            const p = S.player;
            p.vy += G.gravity * dt;
            p.y += p.vy * dt;
            if (p.y > G.groundY()) {
              p.y = G.groundY();
              p.vy = 0;
              p.onGround = true;
              S.jumps = 0;
              if (p.state === "jump") p.state = "runL";
            } else p.onGround = false;

            // Animaci√≥n
            if (p.onGround) {
              p.frameTimer += dt;
              if (p.frameTimer >= 1 / p.runFps) {
                p.state = p.state === "runL" ? "runR" : "runL";
                p.frameTimer = 0;
              }
            } else p.state = "jump";

            spawn(dt);

            // Mover obs/items
            S.obs.forEach((o) => {
              if (o.type === "bird" || o.type === "block") {
                o.x -= o.vx * dt;
                if (o.type === "bird") {
                  o.flap += dt * 9;
                  o.y += Math.sin(S.t * 4 + o.x * 0.02) * 0.6;
                }
              } else if (o.type === "meteor") {
                o.x -= o.vx * dt;
                o.y += o.vy * dt;
              }
            });
            S.items.forEach((i) => {
              i.x -= i.vx * dt;
              if (i.type === "bonus") {
                i.t += dt;
                i.x += Math.cos(i.phase + i.t * i.freq) * (i.ampX * dt);
                i.y += Math.sin(i.phase * 0.7 + i.t * i.freq) * (i.ampY * dt);
                i.y += i.driftY * dt;
                if (Math.random() < 0.05)
                  i.y += rand(-i.jitter, i.jitter) * 0.05;
                i.y = clamp(i.y, V.H * 0.35, V.H * 0.78);
              }
            });

            // Parallax
            S.front.x -= S.speed * S.front.speedMul * dt;
            if (S.front.x <= -V.W) S.front.x += V.W;
            S.groundScroll.x -= S.groundScroll.speedPx * dt;
            if (S.groundScroll.x <= -V.W) S.groundScroll.x += V.W;

            // √Årea jugador
            const pr = {
              x: p.x + p.w * 0.15,
              y: p.y - p.h + 5,
              w: p.w * 0.7,
              h: p.h - 10,
            };

            // Items
            for (let i = S.items.length - 1; i >= 0; i--) {
              const s = S.items[i];
              if (clampR(s.x, s.y, s.r, pr.x, pr.y, pr.w, pr.h)) {
                S.stars++;
                if (s.type === "bonus") {
                  S.score += 120;
                  puff(s.x, s.y, 8);
                  S.particles.push({
                    x: s.x,
                    y: s.y - 60,
                    vx: 0,
                    vy: 0,
                    r: 0,
                    life: 0.8,
                    text: "+120",
                    color: "#2519e3",
                    stroke: "#3b2f00",
                  });
                  playSfx("sfxBonus");
                } else {
                  S.score += 10;
                  puff(s.x, s.y, 5);
                  playSfx("sfxStar");
                }
                if (S.stars % 4 === 0) {
                  const msg = nextPhrase();
                  const t = bubbleTarget();
                  S.bubble = {
                    text: msg,
                    time: 3.3,
                    x: t.x,
                    y: t.y,
                    lockToPlayer: true,
                  };
                }
                S.items.splice(i, 1);
              } else if (s.x < -80) S.items.splice(i, 1);
            }

            // Colisiones letales
            for (const o of S.obs) {
              if (o.type === "meteor") {
                const mw = o.dw ?? (o.dh ? o.dh * METEOR_AR : METEOR_W);
                const mh = o.dh ?? (o.dw ? o.dw / METEOR_AR : METEOR_H);
                const cx = o.x + mw * (o.rcx ?? -0.24);
                const cy = o.y + mh * (o.rcy ?? 0.08);
                const rr = mh * (o.rr ?? 0.18);
                if (clampR(cx, cy, rr, pr.x, pr.y, pr.w, pr.h)) return over();
                continue;
              }
              const ob = {
                x: o.x + o.w * 0.1,
                y: o.y - o.h,
                w: o.w * 0.8,
                h: o.h,
              };
              if (aabb(pr, ob)) {
                if (o.type === "bird" && p.y < o.y - o.h / 2) continue;
                return over();
              }
            }

            // Limpieza part√≠culas
            S.obs = S.obs.filter((o) => o.x > -120 && o.y < V.H + 140);
            for (let i = S.particles.length - 1; i >= 0; i--) {
              const pa = S.particles[i];
              pa.life -= dt;
              if (pa.life <= 0) {
                S.particles.splice(i, 1);
                continue;
              }
              pa.x += pa.vx * dt;
              pa.y += pa.vy * dt;
              pa.vy += 900 * dt;
            }

            if (S.bubble) {
              S.bubble.time -= dt;
              if (S.bubble.time <= 0) S.bubble = null;
            }
          }

          // ---------- Dibujo ----------
          function drawMeteorProportional(o) {
            const m = img.meteor,
              iw = m.width || METEOR_W,
              ih = m.height || METEOR_H;
            const DW = o.dw ?? (o.dh ? o.dh * METEOR_AR : iw);
            const DH = o.dh ?? (o.dw ? o.dw / METEOR_AR : ih);
            safeDraw(m, 0, 0, iw, ih, o.x - DW / 2, o.y - DH / 2, DW, DH);
          }
          function drawTiled(image, x, y, h) {
            const tex =
              image && image.complete && image.naturalWidth
                ? image
                : img.ground;
            let x0 = Math.floor(x);
            while (x0 > 0) x0 -= V.W;
            for (let xx = x0; xx < V.W; xx += V.W) safeDraw(tex, xx, y, V.W, h);
          }
          function drawSpeechBubble(text, x, y, maxW = 220) {
            ctx.font = "bold 14px system-ui, Arial";
            const words = String(text).split(/\s+/);
            const lines = [];
            let line = "";
            for (const w of words) {
              const t = line ? line + " " + w : w;
              if (ctx.measureText(t).width <= maxW) line = t;
              else {
                if (line) lines.push(line);
                line = w;
              }
            }
            if (line) lines.push(line);
            const lh = 22,
              padX = 12,
              padY = 10;
            const w = Math.min(
              maxW,
              Math.max(...lines.map((t) => ctx.measureText(t).width)) + padX * 2
            );
            const h = lines.length * lh + padY * 2;
            const rx = x - w / 2,
              ry = y - h,
              r = 10;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(rx + r, ry);
            ctx.lineTo(rx + w - r, ry);
            ctx.quadraticCurveTo(rx + w, ry, rx + w, ry + r);
            ctx.lineTo(rx + w, ry + h - r);
            ctx.quadraticCurveTo(rx + w, ry + h, rx + w - r, ry + h);
            const tipX = x + 12,
              tipY = ry + h + 8;
            ctx.lineTo(tipX, ry + h);
            ctx.lineTo(x, tipY);
            ctx.lineTo(x - 12, ry + h);
            ctx.lineTo(rx + r, ry + h);
            ctx.quadraticCurveTo(rx, ry + h, rx, ry + h - r);
            ctx.lineTo(rx, ry + r);
            ctx.quadraticCurveTo(rx, ry, rx + r, ry);
            ctx.closePath();

            ctx.shadowColor = "#0008";
            ctx.shadowBlur = 2;
            ctx.fillStyle = "#f2f2f2";
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#faf";
            ctx.stroke();

            ctx.fillStyle = "#111";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let yy = ry + padY + lh / 2;
            for (const ln of lines) {
              ctx.fillText(ln, x, yy);
              yy += lh;
            }
            ctx.restore();
          }

          // Cache HUD
          const pointsEl = document.getElementById("points");
          const metersEl = document.getElementById("meters");
          const bestEl = document.getElementById("best");
          let lastHUD = { p: -1, m: -1, b: -1 };

          function draw() {
            ctx.clearRect(0, 0, V.W, V.H);
            safeDraw(img.bg, 0, 0, V.W, V.H);

            drawTiled(
              img.ground,
              S.groundScroll.x,
              S.groundScroll.y,
              S.groundScroll.h
            );

            for (const s of S.items) {
              const isBonus = s.type === "bonus";
              const spr = isBonus ? img.starBonus : img.star;
              if (isBonus) {
                const w = s.r * (s.vW || 3.2),
                  h = s.r * (s.vH || 1.6);
                safeDraw(spr, s.x - w / 2, s.y - h / 2, w, h);
              } else {
                const scale = s.vScale || 1,
                  rr = s.r * scale;
                safeDraw(spr, s.x - rr, s.y - rr, rr * 2, rr * 2);
              }
            }

            for (const o of S.obs) {
              if (o.type === "bird")
                safeDraw(img.bird, o.x, o.y - o.h, o.w, o.h);
              else if (o.type === "meteor") drawMeteorProportional(o);
              else
                safeDraw(
                  img.obstacle,
                  o.x,
                  o.y - o.h + BLOCK_VOFFSET,
                  o.w,
                  o.h
                );
            }

            const p = S.player;
            const sprite =
              p.state === "runL"
                ? img.player.runL
                : p.state === "runR"
                  ? img.player.runR
                  : img.player.jump;

            ctx.save();
            const tilt = p.onGround ? 0 : clamp(p.vy / 900, -0.6, 0.6);
            ctx.translate(p.x + p.w / 2, p.y - p.h / 2 + PLAYER_VOFFSET);
            ctx.rotate(tilt);
            safeDraw(sprite, -p.w / 2, -p.h / 2, p.w, p.h);
            ctx.restore();

            if (S.bubble)
              drawSpeechBubble(S.bubble.text, S.bubble.x, S.bubble.y);

            for (const pa of S.particles) {
              ctx.globalAlpha = Math.max(0, Math.min(1, pa.life));
              if (pa.text) {
                ctx.font = "bold 20px system-ui, Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = pa.color || "#a3f";
                ctx.fillText(pa.text, pa.x, pa.y);
              } else {
                ctx.save();
                ctx.translate(pa.x, pa.y);
                ctx.rotate(pa.rot || 0);
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `bold ${Math.round(pa.s)}px system-ui, Apple Color Emoji, Segoe UI Emoji, Arial`;
                ctx.fillStyle = "#ffd33d";
                ctx.strokeStyle = "#c99b1a";
                ctx.lineWidth = 2;
                const glyph = "‚ô™";
                ctx.fillText(glyph, 0, 0);
                ctx.strokeText(glyph, 0, 0);
                ctx.restore();
              }
              ctx.globalAlpha = 1;
            }

            drawTiled(img.groundFront, S.front.x, S.front.y, S.front.h);

            const pNow = Math.floor(S.score);
            const mNow = Math.floor(S.meters);
            if (pNow !== lastHUD.p) {
              if (pointsEl) pointsEl.textContent = pNow;
              lastHUD.p = pNow;
            }
            if (mNow !== lastHUD.m) {
              if (metersEl) metersEl.textContent = mNow;
              lastHUD.m = mNow;
            }
            if (S.best !== lastHUD.b) {
              if (bestEl) bestEl.textContent = S.best;
              lastHUD.b = S.best;
            }
          }

          // ---------- Ciclo de vida ----------
          function start() {
            reset();
            S.running = true;

            // ‚õîÔ∏è Oculta/elimina bot√≥n de p√≥ster al inicio
            window.Poster?.hide();

            const titleEl = document.getElementById("title");
            if (titleEl) titleEl.replaceChildren("¬°A correr!");
            if (subtitleEl) {
              subtitleEl.textContent =
                "Evita obst√°culos, atrapa estrellas. Toca / Espacio / ‚Üë para saltar. Doble salto habilitado.";
            }
            if (statsEl) statsEl.style.display = "none";
            const rewardBtn = document.getElementById("rewardBtn");
            if (rewardBtn) rewardBtn.style.display = "none";
            if (overlay) overlay.classList.remove("show");

            const bgm = document.getElementById("bgm");
            if (bgm && audioReady && !muted) bgm.play().catch(() => {});
          }

          function over() {
            S.running = false;

            const finalPoints = Math.floor(S.score);
            if (finalPoints > S.best) {
              S.best = finalPoints;
              localStorage.setItem("bestPoints", String(S.best));
            }

            const titleEl = document.getElementById("title");
            if (titleEl) {
              const im = new Image();
              im.src = assets.gameOverImg;
              im.alt = "Game Over";
              im.loading = "lazy";
              im.class = "animate pulse";
              im.decoding = "async";
              im.style.display = "block";
              im.style.margin = "12px auto 0";
              im.style.maxWidth = "clamp(200px, 50%, 400px)";
              im.style.height = "auto";
              titleEl.replaceChildren(im);
            }
            if (subtitleEl) {
              subtitleEl.textContent = "Pulsa el bot√≥n ¬´Jugar¬ª para reiniciar.";
            }
            if (statsEl) {
              statsEl.innerHTML = `Puntos: <b>${finalPoints}</b> ¬∑ Distancia: <b>${Math.floor(S.meters)}</b> m ¬∑ R√©cord: <b>${S.best}</b>`;
              statsEl.style.display = "block";
            }
            if (overlay) overlay.classList.add("show");
            canRestartAt = performance.now() + 600;

            // ‚úÖ SOLO en Game Over: mostrar bot√≥n para descargar p√≥ster
            window.Poster?.show({
              score: finalPoints,
              best: S.best,
              meters: Math.floor(S.meters),
              hashtag: "#CazaNubes",
              logoSrc: "assets/caza.webp",
            });

            playSfx("sfxOver");
          }

          if (overlay) overlay.classList.add("show");
        })();
      });
    </script>

    <!-- Poster (integrado) -->
    <script>
      (() => {
        // ======== Utilidades ========
        const loadImage = (src) =>
          new Promise((res, rej) => {
            if (!src) return res(null);
            const im = new Image();
            im.decoding = "async";
            im.loading = "eager";
            im.crossOrigin = "anonymous";
            im.onload = () => res(im);
            im.onerror = () => rej(new Error("No se pudo cargar: " + src));
            im.src = src;
          });

        const roundedRect = (ctx, x, y, w, h, r) => {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.lineTo(x + w - rr, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
          ctx.lineTo(x + w, y + h - rr);
          ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
          ctx.lineTo(x + rr, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
          ctx.lineTo(x, y + rr);
          ctx.quadraticCurveTo(x, y, x + rr, y);
          ctx.closePath();
        };

        const dl = (dataURL, filename) => {
          const a = document.createElement("a");
          a.href = dataURL;
          a.download = filename || "poster.png";
          document.body.appendChild(a);
          a.click();
          a.remove();
        };

        // ======== Motor de p√≥ster ========
        const Poster = {
          cfg: {
            width: 1080,
            height: 1350,
            hashtag: "#CazaNubes",
            title: "HUMBE | CAZA NUBES",
            logoSrc: "assets/caza.webp",
            gradFrom: "#1d01ff",
            gradTo: "#ffd33d",
            panel: "#0b0b12",
            textMain: "#ffffff",
            textAccent: "#ffd33d",
          },
          _logo: null,
          _canvas: null,
          _ctx: null,
          _btn: null,

          async setup(options = {}) {
            Object.assign(this.cfg, options);
            if (!this._canvas) {
              this._canvas = document.createElement("canvas");
              this._canvas.width = this.cfg.width;
              this._canvas.height = this.cfg.height;
              this._ctx = this._canvas.getContext("2d");
            }
            try {
              this._logo = await loadImage(this.cfg.logoSrc);
            } catch {
              this._logo = null;
            }
          },

          async make(data = {}) {
            const {
              gameCanvas,
              score = 0,
              best = 0,
              meters = 0,
              hashtag = this.cfg.hashtag,
            } = data;

            if (!this._ctx) await this.setup();

            const { width: W, height: H } = this._canvas;
            const ctx = this._ctx;

            // Fondo degradado
            const grad = ctx.createLinearGradient(0, 0, W, H);
            grad.addColorStop(0, this.cfg.gradFrom);
            grad.addColorStop(1, this.cfg.gradTo);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Panel central
            const panelPad = 48;
            const panelR = 38;
            ctx.save();
            ctx.shadowColor = "#0009";
            ctx.shadowBlur = 30;
            ctx.shadowOffsetY = 8;
            ctx.fillStyle = this.cfg.panel;
            roundedRect(
              ctx,
              panelPad,
              panelPad,
              W - panelPad * 2,
              H - panelPad * 2,
              panelR
            );
            ctx.fill();
            ctx.restore();

            // Preview del juego
            if (gameCanvas && gameCanvas.width && gameCanvas.height) {
              const gw = gameCanvas.width;
              const gh = gameCanvas.height;

              const ph = Math.round(H * 0.38);
              const pw = Math.round(W - panelPad * 2 - 80);
              const px = Math.round((W - pw) / 2);
              const py = panelPad + 60;

              const ar = gw / gh;
              let dw = pw,
                dh = Math.round(pw / ar);
              if (dh > ph) {
                dh = ph;
                dw = Math.round(ph * ar);
              }
              const dx = Math.round(px + (pw - dw) / 2);
              const dy = Math.round(py + (ph - dh) / 2);

              ctx.save();
              ctx.shadowColor = "#0008";
              ctx.shadowBlur = 18;
              ctx.fillStyle = "#0e0e18";
              roundedRect(ctx, px, py, pw, ph, 28);
              ctx.fill();
              ctx.restore();

              ctx.save();
              roundedRect(ctx, dx, dy, dw, dh, 24);
              ctx.clip();
              ctx.drawImage(gameCanvas, 0, 0, gw, gh, dx, dy, dw, dh);
              ctx.restore();
            }

            // Logo
            if (this._logo) {
              const lw = Math.min(480, Math.round(W * 0.56));
              const ar = this._logo.width / this._logo.height || 2.5;
              const lh = Math.round(lw / ar);
              const lx = Math.round((W - lw) / 2);
              const ly = panelPad + 24;

              ctx.save();
              ctx.shadowColor = "#0007";
              ctx.shadowBlur = 16;
              roundedRect(ctx, lx - 12, ly - 12, lw + 24, lh + 24, 20);
              ctx.fillStyle = "rgba(255,255,255,0.04)";
              ctx.fill();
              ctx.drawImage(this._logo, lx, ly, lw, lh);
              ctx.restore();
            }

            // T√≠tulo
            ctx.save();
            ctx.font =
              "900 46px system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = this.cfg.textMain;
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(this.cfg.title, W / 2, Math.round(H * 0.5));

            // Score grande
            const big = 140;
            ctx.font = `900 ${big}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
            ctx.lineWidth = 10;
            ctx.strokeStyle = "rgba(0,0,0,0.35)";
            ctx.textBaseline = "middle";
            ctx.strokeText(String(score), W / 2, Math.round(H * 0.63));
            ctx.fillStyle = this.cfg.textAccent;
            ctx.fillText(String(score), W / 2, Math.round(H * 0.63));

            // Substats
            ctx.font =
              "700 40px system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = "#ffffff";
            ctx.textBaseline = "top";
            const line1 = `R√©cord: ${best}`;
            const line2 = `Distancia: ${Math.floor(meters)} m`;
            ctx.fillText(line1, W / 2, Math.round(H * 0.72));
            ctx.fillText(line2, W / 2, Math.round(H * 0.77));
            ctx.restore();

            // Hashtag
            ctx.save();
            ctx.font =
              "800 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText(hashtag || this.cfg.hashtag, W / 2, H - panelPad - 12);
            ctx.restore();

            // Fecha
            ctx.save();
            ctx.font =
              "600 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = "rgba(255,255,255,0.7)";
            ctx.textAlign = "right";
            ctx.textBaseline = "bottom";
            const date = new Date();
            const stamp = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
            ctx.fillText(stamp, W - panelPad - 8, H - panelPad - 8);
            ctx.restore();

            return this._canvas.toDataURL("image/png");
          },

          // Inserta/actualiza bot√≥n en overlay
          ensureButton() {
            const overlay = document.getElementById("overlay");
            if (!overlay) return null;

            const holder = overlay.querySelector("div");
            if (!holder) return null;

            let btn = overlay.querySelector("#downloadPosterBtn");
            if (!btn) {
              btn = document.createElement("div");
              btn.id = "downloadPosterBtn";
              btn.className = "btn";
              btn.textContent = "Descargar p√≥ster";
              btn.style.marginLeft = "10px";
              const start = overlay.querySelector("#startBtn");
              if (start && start.parentElement === holder) {
                start.insertAdjacentElement("afterend", btn);
              } else {
                holder.appendChild(btn);
              }
            }
            this._btn = btn;
            return btn;
          },

          // Elimina el bot√≥n si existe (para que NO salga al inicio)
          removeButton() {
            const btn = document.getElementById("downloadPosterBtn");
            if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
            this._btn = null;
          },

          // API simple para esconderlo durante el inicio
          hide() {
            this.removeButton();
          },

          // SOLO llamar en Game Over
          async show({ score, best, meters, hashtag, logoSrc } = {}) {
            await this.setup({
              logoSrc: logoSrc || this.cfg.logoSrc,
              hashtag: hashtag || this.cfg.hashtag,
            });

            const btn = this.ensureButton();
            if (!btn) return;

            const gameCanvas = document.getElementById("game");

            btn.onclick = async (ev) => {
              ev.stopPropagation();
              btn.textContent = "Generando‚Ä¶";
              btn.style.opacity = "0.7";
              try {
                const dataURL = await this.make({
                  gameCanvas,
                  score,
                  best,
                  meters,
                  hashtag,
                });
                dl(
                  dataURL,
                  `Poster-Humbe-${String(score).padStart(5, "0")}.png`
                );
              } catch (err) {
                console.error(err);
                alert("No se pudo generar el p√≥ster.");
              } finally {
                btn.textContent = "Descargar p√≥ster";
                btn.style.opacity = "1";
              }
            };
          },
        };

        // expone global
        window.Poster = Poster;
      })();
    </script>
  </body>
</html>
